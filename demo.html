<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Hilbert Curve Sort Demo</title>
		<script>
			const rand = (a, b) => Math.random() * (b - a) + a;

			async function hilbertCurveSort2d(vectors) {
				// Base

				// Equal vectors / empty quadrant
				if (vectors.length < 2 || new Set(vectors.map(String)).size < 2) return vectors;

				// Recursion

				let [minX, minY] = ([maxX, maxY] = vectors[0]);
				for (const [x, y] of vectors) {
					if (x < minX) minX = x;
					else if (x > maxX) maxX = x;
					if (y < minY) minY = y;
					else if (y > maxY) maxY = y;
				}
				const maxSide = Math.max(maxX - minX, maxY - minY);
				let step = 0;
				let tmp = maxSide + 1;
				while ((tmp >>= 1) !== 0) step++;

				const side = (1 << step) - 1;
				let scaleX = side / (maxX - minX);
				let scaleY = side / (maxY - minY);
				if (scaleX === 0 || !Number.isFinite(scaleX)) scaleX = 1;
				if (scaleY === 0 || !Number.isFinite(scaleY)) scaleY = 1;
				const mid = step === 0 ? maxSide / 2 : (1 << (step - 1)) - 0.5;

				// Sub-quadrants according to Gray code sequence G_2
				const [q00, q01, q11, q10] = [[], [], [], []];
				for (let [x, y] of vectors) {
					// Fit vector to origin square with scale 2^n
					x = scaleX * (x - minX);
					y = scaleY * (y - minY);

					switch (((x > mid) << 1) + (y > mid)) {
						case 0b00:
							q00.push([y, x]);
							break;
						case 0b01:
							q01.push([x, y]);
							break;
						case 0b11:
							q11.push([x, y]);
							break;
						case 0b10:
							q10.push([-y, -x]);
							break;
					}
				}

				const sorted = await Promise.all([
					hilbertCurveSort2d(q00).then((res) => res.map(([x, y]) => [y, x])),
					hilbertCurveSort2d(q01),
					hilbertCurveSort2d(q11),
					hilbertCurveSort2d(q10).then((res) => res.map(([x, y]) => [-y, -x])),
				]);

				// De-fitting
				return sorted.flat().map(([x, y]) => [x / scaleX + minX, y / scaleY + minY]);
			}

			async function hilbertCurveSort3d(vectors) {
				// Base

				// Equal vectors / empty quadrant
				if (vectors.length < 2 || new Set(vectors.map(String)).size < 2) return vectors;

				// Recursion

				let [minX, minY, minZ] = ([maxX, maxY, maxZ] = vectors[0]);
				for (const [x, y, z] of vectors) {
					if (x < minX) minX = x;
					else if (x > maxX) maxX = x;
					if (y < minY) minY = y;
					else if (y > maxY) maxY = y;
					if (z < minZ) minZ = z;
					else if (z > maxZ) maxZ = z;
				}
				const maxSide = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
				let step = 0;
				let tmp = maxSide + 1;
				while ((tmp >>= 1) !== 0) step++;

				const side = (1 << step) - 1;
				let scaleX = side / (maxX - minX);
				let scaleY = side / (maxY - minY);
				let scaleZ = side / (maxZ - minZ);
				if (scaleX === 0 || !Number.isFinite(scaleX)) scaleX = 1;
				if (scaleY === 0 || !Number.isFinite(scaleY)) scaleY = 1;
				if (scaleZ === 0 || !Number.isFinite(scaleZ)) scaleZ = 1;
				const mid = step === 0 ? maxSide / 2 : (1 << (step - 1)) - 0.5;

				// Sub-octants according to Gray code sequence G_3
				const [o000, o001, o011, o010, o110, o111, o101, o100] = [[], [], [], [], [], [], [], []];
				for (let [x, y, z] of vectors) {
					// Fit vector to origin cube with scale 2^n
					x = scaleX * (x - minX);
					y = scaleY * (y - minY);
					z = scaleZ * (z - minZ);

					switch (((x > mid) << 2) + ((y > mid) << 1) + (z > mid)) {
						case 0b000:
							o000.push([z, x, y]);
							break;
						case 0b001:
							o001.push([y, z, x]);
							break;
						case 0b011:
							o011.push([y, z, x]);
							break;
						case 0b010:
							o010.push([x, -y, -z]);
							break;
						case 0b110:
							o110.push([x, -y, -z]);
							break;
						case 0b111:
							o111.push([-y, z, -x]);
							break;
						case 0b101:
							o101.push([-y, z, -x]);
							break;
						case 0b100:
							o100.push([-z, -x, y]);
							break;
					}
				}

				const sorted = await Promise.all([
					hilbertCurveSort3d(o000).then((res) => res.map(([x, y, z]) => [y, z, x])),
					hilbertCurveSort3d(o001).then((res) => res.map(([x, y, z]) => [z, x, y])),
					hilbertCurveSort3d(o011).then((res) => res.map(([x, y, z]) => [z, x, y])),
					hilbertCurveSort3d(o010).then((res) => res.map(([x, y, z]) => [x, -y, -z])),
					hilbertCurveSort3d(o110).then((res) => res.map(([x, y, z]) => [x, -y, -z])),
					hilbertCurveSort3d(o111).then((res) => res.map(([x, y, z]) => [-z, -x, y])),
					hilbertCurveSort3d(o101).then((res) => res.map(([x, y, z]) => [-z, -x, y])),
					hilbertCurveSort3d(o100).then((res) => res.map(([x, y, z]) => [-y, z, -x])),
				]);

				// De-fitting
				return sorted.flat().map(([x, y, z]) => [x / scaleX + minX, y / scaleY + minY, z / scaleZ + minZ]);
			}
		</script>
		<style>
			* {
				box-sizing: border-box;
			}

			.flex {
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.col {
				flex-direction: column;
			}

			section {
				border: 3px black solid;
				width: 100vw;
				padding-bottom: 20px;
			}

			#pts2d-demo canvas {
				background-color: aliceblue;
				margin-right: 4vw;
			}
			#pts2d-demo textarea {
				width: 25vw;
				height: 30vw;
				resize: none;
				margin-bottom: 5px;
			}
			#pts2d-actions button {
				width: 10vw;
				height: 5vw;
				font-size: 1.7vw;
			}
			#pts2d-actions input {
				width: 10vw;
				height: 3vw;
				margin-top: 5px;
				font-size: 1.5vw;
			}
		</style>
	</head>

	<body>
		<main class="flex col">
			<h1>Hilbert Curve Sort Demos</h1>
			<br />
			<section id="pts2d" class="flex col">
				<h2>2D Points</h2>
				<div id="pts2d-demo" class="flex">
					<canvas>sorted 2d points connected in order</canvas>
					<div id="pts2d-actions" class="flex col">
						<textarea
							placeholder="1 1
4 5
1 4"
						></textarea>
						<button id="pts2d-set">Set</button>
						<br />
						<button id="pts2d-random">Random</button>
						<input type="number" placeholder="Number Pts" />
					</div>
				</div>
			</section>
			<br />
		</main>
		<script>
			const pageWidth = window.innerWidth;
			const pageHeight = window.innerHeight;

			const pts2dCvs = document.querySelector("#pts2d-demo canvas");
			const pts2dPts = document.querySelector("#pts2d-actions textarea");
			const pts2dSet = document.querySelector("#pts2d-set");
			const pts2dRdm = document.querySelector("#pts2d-random");
			const pts2dN = document.querySelector("#pts2d-actions input");

			const pts2dSide = pageWidth * 0.45;
			const pts2dCtxt = pts2dCvs.getContext("2d");
			pts2dCvs.setAttribute("width", pts2dSide);
			pts2dCvs.setAttribute("height", pts2dSide);

			async function draw2dPts(pts) {
				pts2dCtxt.clearRect(0, 0, pts2dSide, pts2dSide);
				const sorted = await hilbertCurveSort2d(pts);
				pts2dCtxt.moveTo(...sorted[0]);
				pts2dCtxt.beginPath();
				for (const [x, y] of sorted) {
					if (sorted.length <= 500) pts2dCtxt.fillRect(x - 3, y - 3, 6, 6);
					pts2dCtxt.lineTo(x, y);
				}
				pts2dCtxt.moveTo(...sorted[0]);
				pts2dCtxt.closePath();
				pts2dCtxt.stroke();
			}
			function drawRdmPts(n) {
				const pts = [...Array(n)].map(() => [rand(0, pts2dSide), rand(0, pts2dSide)]);
				draw2dPts(pts);
			}

			drawRdmPts(100);
			pts2dSet.addEventListener("click", () => {
				try {
					const pts = pts2dPts.value.split("\n").map((coords) => coords.split(" ").map(Number));
					let [minX, minY] = ([maxX, maxY] = pts[0]);
					for (const [x, y] of pts) {
						if (x < minX) minX = x;
						else if (x > maxX) maxX = x;
						if (y < minY) minY = y;
						else if (y > maxY) maxY = y;
					}
					const scaleX = (pts2dSide - 20) / (maxX - minX);
					const scaleY = (pts2dSide - 20) / (maxY - minY);
					draw2dPts(pts.map(([x, y]) => [scaleX * x - minX + 10, scaleY * y - minY + 10]));
				} catch {
					pts2dPts.value = "";
				}
			});
			pts2dRdm.addEventListener("click", () => {
				let n = Number(pts2dN.value);
				if (!n) n = 100;
				drawRdmPts(n);
			});
		</script>
	</body>
</html>
