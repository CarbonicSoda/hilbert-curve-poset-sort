<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Hilbert Curve Sort Demo</title>
		<script>
			const rand = (a, b) => Math.random() * (b - a) + a;

			async function hilbertCurveSort2d(vectors) {
				// Base

				// Equal vectors / empty quadrant
				if (vectors.length < 2 || new Set(vectors.map(String)).size < 2) return vectors;

				// Recursion

				let [minX, minY] = ([maxX, maxY] = vectors[0]);
				for (const [x, y] of vectors) {
					if (x < minX) minX = x;
					else if (x > maxX) maxX = x;
					if (y < minY) minY = y;
					else if (y > maxY) maxY = y;
				}
				const maxSide = Math.max(maxX - minX, maxY - minY);
				let step = 0;
				let tmp = maxSide + 1;
				while ((tmp >>= 1) !== 0) step++;

				const side = (1 << step) - 1;
				let scaleX = side / (maxX - minX);
				let scaleY = side / (maxY - minY);
				if (scaleX === 0 || !Number.isFinite(scaleX)) scaleX = 1;
				if (scaleY === 0 || !Number.isFinite(scaleY)) scaleY = 1;
				const mid = step === 0 ? maxSide / 2 : (1 << (step - 1)) - 0.5;

				// Sub-quadrants according to Gray code sequence G_2
				const [q00, q01, q11, q10] = [[], [], [], []];
				for (let [x, y] of vectors) {
					// Fit vector to origin square with scale 2^n
					x = scaleX * (x - minX);
					y = scaleY * (y - minY);

					switch (((x > mid) << 1) + (y > mid)) {
						case 0b00:
							q00.push([y, x]);
							break;
						case 0b01:
							q01.push([x, y]);
							break;
						case 0b11:
							q11.push([x, y]);
							break;
						case 0b10:
							q10.push([-y, -x]);
							break;
					}
				}

				const sorted = await Promise.all([
					hilbertCurveSort2d(q00).then((res) => res.map(([x, y]) => [y, x])),
					hilbertCurveSort2d(q01),
					hilbertCurveSort2d(q11),
					hilbertCurveSort2d(q10).then((res) => res.map(([x, y]) => [-y, -x])),
				]);

				// De-fitting
				return sorted.flat().map(([x, y]) => [x / scaleX + minX, y / scaleY + minY]);
			}

			async function hilbertCurveSort3d(vectors) {
				// Base

				// Equal vectors / empty quadrant
				if (vectors.length < 2 || new Set(vectors.map(String)).size < 2) return vectors;

				// Recursion

				let [minX, minY, minZ] = ([maxX, maxY, maxZ] = vectors[0]);
				for (const [x, y, z] of vectors) {
					if (x < minX) minX = x;
					else if (x > maxX) maxX = x;
					if (y < minY) minY = y;
					else if (y > maxY) maxY = y;
					if (z < minZ) minZ = z;
					else if (z > maxZ) maxZ = z;
				}
				const maxSide = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
				let step = 0;
				let tmp = maxSide + 1;
				while ((tmp >>= 1) !== 0) step++;

				const side = (1 << step) - 1;
				let scaleX = side / (maxX - minX);
				let scaleY = side / (maxY - minY);
				let scaleZ = side / (maxZ - minZ);
				if (scaleX === 0 || !Number.isFinite(scaleX)) scaleX = 1;
				if (scaleY === 0 || !Number.isFinite(scaleY)) scaleY = 1;
				if (scaleZ === 0 || !Number.isFinite(scaleZ)) scaleZ = 1;
				const mid = step === 0 ? maxSide / 2 : (1 << (step - 1)) - 0.5;

				// Sub-octants according to Gray code sequence G_3
				const [o000, o001, o011, o010, o110, o111, o101, o100] = [[], [], [], [], [], [], [], []];
				for (let [x, y, z] of vectors) {
					// Fit vector to origin cube with scale 2^n
					x = scaleX * (x - minX);
					y = scaleY * (y - minY);
					z = scaleZ * (z - minZ);

					switch (((x > mid) << 2) + ((y > mid) << 1) + (z > mid)) {
						case 0b000:
							o000.push([z, x, y]);
							break;
						case 0b001:
							o001.push([y, z, x]);
							break;
						case 0b011:
							o011.push([y, z, x]);
							break;
						case 0b010:
							o010.push([x, -y, -z]);
							break;
						case 0b110:
							o110.push([x, -y, -z]);
							break;
						case 0b111:
							o111.push([-y, z, -x]);
							break;
						case 0b101:
							o101.push([-y, z, -x]);
							break;
						case 0b100:
							o100.push([-z, -x, y]);
							break;
					}
				}

				const sorted = await Promise.all([
					hilbertCurveSort3d(o000).then((res) => res.map(([x, y, z]) => [y, z, x])),
					hilbertCurveSort3d(o001).then((res) => res.map(([x, y, z]) => [z, x, y])),
					hilbertCurveSort3d(o011).then((res) => res.map(([x, y, z]) => [z, x, y])),
					hilbertCurveSort3d(o010).then((res) => res.map(([x, y, z]) => [x, -y, -z])),
					hilbertCurveSort3d(o110).then((res) => res.map(([x, y, z]) => [x, -y, -z])),
					hilbertCurveSort3d(o111).then((res) => res.map(([x, y, z]) => [-z, -x, y])),
					hilbertCurveSort3d(o101).then((res) => res.map(([x, y, z]) => [-z, -x, y])),
					hilbertCurveSort3d(o100).then((res) => res.map(([x, y, z]) => [-y, z, -x])),
				]);

				// De-fitting
				return sorted.flat().map(([x, y, z]) => [x / scaleX + minX, y / scaleY + minY, z / scaleZ + minZ]);
			}
		</script>
		<style>
			* {
				box-sizing: border-box;
			}

			.flex {
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.col {
				flex-direction: column;
			}

			section {
				border-top: 3px black solid;
				width: 100vw;
				padding-bottom: 20px;
			}
			textarea {
				width: 10vw;
				height: 15vw;
				font-size: 1.7vw;
				resize: none;
			}
			input {
				width: 10vw;
				height: 3vw;
				font-size: 1.5vw;
			}
			button {
				width: 10vw;
				height: 5vw;
				margin: 10px;
				font-size: 1.7vw;
			}

			#pts2d-demo canvas {
				background-color: whitesmoke;
				border: 3px lightgrey solid;
				margin-right: 4vw;
			}
			#colors-canvases {
				margin-bottom: 20px;
			}
			#colors-actions p {
				width: 10vw;
			}
		</style>
	</head>

	<body>
		<main class="flex col">
			<h1>Hilbert Curve Sort Demos</h1>
			<br />
			<section id="pts2d" class="flex col">
				<h2>2D Points</h2>
				<div id="pts2d-demo" class="flex">
					<canvas>sorted 2d points connected in order</canvas>
					<div id="pts2d-actions" class="flex col">
						<textarea></textarea>
						<button id="pts2d-set">Set</button>
						<br />
						<br />
						<input type="number" placeholder="Num Points" />
						<button id="pts2d-random">Random</button>
					</div>
				</div>
			</section>
			<br />
			<section id="colors" class="flex col">
				<h2>Colors (sRGB)</h2>
				<div id="colors-demo" class="flex col">
					<div id="colors-canvases" class="flex col">
						<canvas id="colors-original">original color ordering</canvas>
						<br />
						<canvas id="colors-sorted">sorted color ordering</canvas>
					</div>
					<div id="colors-actions" class="flex">
						<textarea></textarea>
						<button id="colors-set">Set</button>
						<p></p>
						<input type="number" placeholder="Num Colors" />
						<button id="colors-random">Random</button>
					</div>
				</div>
			</section>
		</main>
		<script>
			const pageWidth = window.innerWidth;
			const pageHeight = window.innerHeight;

			// 2D Points Section
			const pts2dCvs = document.querySelector("#pts2d-demo canvas");
			const pts2dPts = document.querySelector("#pts2d-actions textarea");
			const pts2dSet = document.querySelector("#pts2d-set");
			const pts2dRdmN = document.querySelector("#pts2d-actions input");
			const pts2dRdm = document.querySelector("#pts2d-random");

			const pts2dCtx = pts2dCvs.getContext("2d");
			const pts2dSide = pageWidth * 0.45;
			pts2dCvs.setAttribute("width", pts2dSide);
			pts2dCvs.setAttribute("height", pts2dSide);

			async function draw2dPts(pts) {
				pts2dCtx.clearRect(0, 0, pts2dSide, pts2dSide);

				const sorted = await hilbertCurveSort2d(pts);
				pts2dCtx.moveTo(...sorted[0]);
				pts2dCtx.beginPath();
				for (let [x, y] of sorted) {
					y = pts2dSide - y;
					if (sorted.length <= 500) pts2dCtx.fillRect(x - 4, y - 4, 8, 8);
					pts2dCtx.lineTo(x, y);
				}
				pts2dCtx.moveTo(...sorted[0]);
				pts2dCtx.closePath();
				pts2dCtx.stroke();
			}

			function drawSetPts(_pts) {
				const pts = (_pts ?? pts2dPts.value)
					.trim()
					.split("\n")
					.map((coords) => coords.split(" ").map(Number))
					.filter((vec) => vec.length === 2 && vec.every(Number.isFinite));
				if (pts.length < 2) {
					drawSetPts(pts2dPts.getAttribute("placeholder"));
					return;
				}
				let [minX, minY] = ([maxX, maxY] = pts[0]);
				for (const [x, y] of pts) {
					if (x < minX) minX = x;
					else if (x > maxX) maxX = x;
					if (y < minY) minY = y;
					else if (y > maxY) maxY = y;
				}
				const scaleX = (pts2dSide - 40) / (maxX - minX);
				const scaleY = (pts2dSide - 40) / (maxY - minY);
				draw2dPts(pts.map(([x, y]) => [scaleX * x - minX + 20, scaleY * y - minY + 20]));
			}
			pts2dSet.addEventListener("click", () => drawSetPts());
			pts2dRdm.addEventListener("click", () => {
				let n = Number(pts2dRdmN.value);
				if (!n) n = 100;
				const pts = [...Array(n)].map(() => [rand(0, pts2dSide), rand(0, pts2dSide)]);
				draw2dPts(pts);
			});

			pts2dPts.setAttribute("placeholder", "0 0\n0 1\n1 0\n1 1");
			drawSetPts();

			// Colors (sRGB) Section
			const clrsOriginalCvs = document.querySelector("#colors-original");
			const clrsSortedCvs = document.querySelector("#colors-sorted");
			const clrsInput = document.querySelector("#colors-actions textarea");
			const clrsSet = document.querySelector("#colors-set");
			const clrsRdmN = document.querySelector("#colors-actions input");
			const clrsRdm = document.querySelector("#colors-random");

			const clrsOriginalCtx = clrsOriginalCvs.getContext("2d");
			const clrsSortedCtx = clrsSortedCvs.getContext("2d");
			const clrsCvsWidth = pageWidth * 0.9;
			const clrsCvsHeight = pageHeight * 0.1;
			clrsOriginalCvs.setAttribute("width", clrsCvsWidth);
			clrsOriginalCvs.setAttribute("height", clrsCvsHeight);
			clrsSortedCvs.setAttribute("width", clrsCvsWidth);
			clrsSortedCvs.setAttribute("height", clrsCvsHeight);

			async function drawClrs(clrs) {
				clrsOriginalCtx.clearRect(0, 0, clrsCvsWidth, clrsCvsHeight);
				clrsSortedCtx.clearRect(0, 0, clrsCvsWidth, clrsCvsHeight);
				const clrWidth = clrsCvsWidth / clrs.length;

				for (let i = 0; i < clrs.length; i++) {
					const [r, g, b] = clrs[i];
					clrsOriginalCtx.fillStyle = `rgb(${r} ${g} ${b})`;
					clrsOriginalCtx.fillRect(i * clrWidth, 0, clrWidth, clrsCvsHeight);
				}

				const sorted = await hilbertCurveSort3d(clrs);
				for (let i = 0; i < sorted.length; i++) {
					const [r, g, b] = sorted[i];
					clrsSortedCtx.fillStyle = `rgb(${r} ${g} ${b})`;
					clrsSortedCtx.fillRect(i * clrWidth, 0, clrWidth, clrsCvsHeight);
				}
			}

			function drawSetClrs(_clrs) {
				const clrs = (_clrs ?? clrsInput.value)
					.trim()
					.split("\n")
					.map((value) => value.split(" ").map(Number))
					.filter((rgb) => rgb.length === 3 && rgb.every(Number.isFinite));
				if (clrs.length < 2) {
					drawSetClrs(clrsInput.getAttribute("placeholder"));
					return;
				}
				drawClrs(clrs);
			}
			clrsSet.addEventListener("click", () => drawSetClrs());

			function rdmClrs(n) {
				return (clrs = [...Array(n)].map(() => [rand(0, 255), rand(0, 255), rand(0, 255)]));
			}
			clrsRdm.addEventListener("click", () => {
				let n = Number(clrsRdmN.value);
				if (!n) n = 100;
				drawClrs(rdmClrs(n));
			});

			// clrsInput.setAttribute(
			// 	"placeholder",
			// 	rdmClrs(1024)
			// 		.map((rgb) => rgb.map(Math.trunc).join(" "))
			// 		.join("\n"),
			// );
			
			// const step = 5;
			const step = 15;
			const bits = [...Array(Math.trunc(255 / step) + 1).keys()].map((b) => step * b);
			const rgbUniform = bits.flatMap((r) => bits.flatMap((g) => bits.map((b) => [r, g, b])));
			clrsInput.setAttribute("placeholder", rgbUniform.map((rgb) => rgb.join(" ")).join("\n"));
			drawSetClrs();
		</script>
	</body>
</html>
